#!/usr/bin/env python3
"""
Universal Image to Zig Converter for NanoOS
Converts images (wallpapers, icons, logos) to Zig-compatible pixel data.
"""

try:
    from PIL import Image
    import sys
    import os
    import argparse
except ImportError:
    print("Error: PIL (Pillow) not installed. Install with: pip install Pillow")
    sys.exit(1)

def convert_image_to_zig(input_path, output_path, asset_type="wallpaper", max_size=None):
    """
    Convert image to Zig array format.
    
    Args:
        input_path: Source image file
        output_path: Output .zig file
        asset_type: Type of asset (wallpaper, icon, logo)
        max_size: Max dimensions (width, height) tuple
    """
    
    # Load image
    img = Image.open(input_path)
    
    # Apply size constraints based on asset type
    if asset_type == "wallpaper":
        max_size = max_size or (1920, 1080)
    elif asset_type == "icon":
        max_size = max_size or (64, 64)
    elif asset_type == "logo":
        max_size = max_size or (128, 128)
    
    # Resize if needed
    if max_size:
        img.thumbnail(max_size, Image.Resampling.LANCZOS)
    
    # Convert to RGBA
    img = img.convert('RGBA')
    
    width, height = img.size
    pixels = img.load()
    
    # Generate base name from filename
    base_name = os.path.splitext(os.path.basename(input_path))[0].upper()
    base_name = base_name.replace("-", "_") # Handle hyphens
    
    # Generate Zig code
    zig_code = f"""// Auto-generated {asset_type} data
// Source: {os.path.basename(input_path)}
// Resolution: {width}x{height}
// Generated by: scripts/convert_assets.py

const Color = @import("../../../hal/framebuffer.zig").Color;

pub const {base_name}_WIDTH: u32 = {width};
pub const {base_name}_HEIGHT: u32 = {height};

"""
    
    # Create color palette to reduce data size
    colors_used = set()
    for y in range(height):
        for x in range(width):
            r, g, b, a = pixels[x, y]
            colors_used.add((r, g, b, a))
    
    # Quantize if too many colors
    max_colors = 256 if asset_type == "wallpaper" else 256 # Increased for better quality
    if len(colors_used) > max_colors:
        img = img.quantize(colors=max_colors)
        img = img.convert('RGBA')
        pixels = img.load()
        colors_used = set()
        for y in range(height):
            for x in range(width):
                r, g, b, a = pixels[x, y]
                colors_used.add((r, g, b, a))
    
    # Build palette
    zig_code += f"// Color palette ({len(colors_used)} colors)\n"
    zig_code += "const palette = [_]Color{\n"
    
    color_to_index = {}
    for idx, (r, g, b, a) in enumerate(sorted(colors_used)):
        zig_code += f"    Color{{ .r = {r}, .g = {g}, .b = {b}, .a = {a} }},\n"
        color_to_index[(r, g, b, a)] = idx
    
    zig_code += "};\n\n"
    
    # Generate pixel indices
    zig_code += "// Pixel data as palette indices\n"
    zig_code += "const pixel_data = [_]u8{\n"
    
    for y in range(height):
        zig_code += "    "
        for x in range(width):
            r, g, b, a = pixels[x, y]
            idx = color_to_index[(r, g, b, a)]
            zig_code += f"{idx},"
        zig_code += "\n"
    
    zig_code += "};\n\n"
    
    # Add getter functions
    zig_code += f"""
/// Get pixel at exact coordinates
pub fn getPixel(x: u32, y: u32) Color {{
    if (x >= {base_name}_WIDTH or y >= {base_name}_HEIGHT) {{
        return Color{{ .r = 0, .g = 0, .b = 0, .a = 0 }};
    }}
    const idx = y * {base_name}_WIDTH + x;
    const palette_idx = pixel_data[idx];
    return palette[palette_idx];
}}

/// Get pixel with scaling to fit target dimensions
pub fn getScaledPixel(x: u32, y: u32, target_width: u32, target_height: u32) Color {{
    const src_x = (x * {base_name}_WIDTH) / target_width;
    const src_y = (y * {base_name}_HEIGHT) / target_height;
    return getPixel(src_x, src_y);
}}
"""
    
    # Write to file
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    with open(output_path, 'w') as f:
        f.write(zig_code)
    
    file_size_kb = os.path.getsize(output_path) / 1024
    
    print(f"âœ“ Converted {asset_type}: {input_path}")
    print(f"  Resolution: {width}x{height}")
    print(f"  Colors: {len(colors_used)}")
    print(f"  Output: {output_path}")
    print(f"  Size: {file_size_kb:.1f} KB")
    
    return True

def main():
    parser = argparse.ArgumentParser(description='Convert images to Zig pixel data for NanoOS')
    parser.add_argument('input', help='Input image file')
    parser.add_argument('-o', '--output', help='Output .zig file (auto-generated if not specified)')
    parser.add_argument('-t', '--type', choices=['wallpaper', 'icon', 'logo'], 
                       default='wallpaper', help='Asset type')
    parser.add_argument('--max-width', type=int, help='Maximum width')
    parser.add_argument('--max-height', type=int, help='Maximum height')
    
    args = parser.parse_args()
    
    # Auto-generate output path if not specified
    if not args.output:
        base_name = os.path.splitext(os.path.basename(args.input))[0]
        if args.type == 'wallpaper':
            args.output = f"src/assets/wallpapers/{base_name}_data.zig"
        elif args.type == 'icon':
            args.output = f"src/assets/icons/apps/{base_name}_data.zig"
        elif args.type == 'logo':
            args.output = f"src/assets/icons/system/{base_name}_data.zig"
    
    max_size = None
    if args.max_width and args.max_height:
        max_size = (args.max_width, args.max_height)
    
    if not os.path.exists(args.input):
        print(f"Error: Input file '{args.input}' not found")
        return 1
    
    try:
        convert_image_to_zig(args.input, args.output, args.type, max_size)
        return 0
    except Exception as e:
        print(f"Error: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
